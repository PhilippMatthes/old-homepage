{% load is_night %}
{% load staticfiles %}

<footer id="contact" class="p-4 {% if now|is_night %}bg-dark-custom{% else %}bg-light{% endif %} text-center" style="width: 100%; z-index: 1337;">
    <div id="visualization-demo" style="height: 500px; width: 100%;">
    </div>
    <div class="container {% if now|is_night %}text-light{% else %}text-dark{% endif %} text-center">
        <h1 class="fancy header bg-gradient-target bg-clip-text {{ gradient.css_class }}">
            Contact
        </h1>
        <img src="{% static 'img/me.jpeg' %}" class="mt-3 mb-3" style="width: 200px; max-width: 100%; -webkit-border-radius: 100px;-moz-border-radius: 100px;border-radius: 100px;">
        <h5><a class="{% if now|is_night %}text-light{% else %}text-dark{% endif %}" href="tel:+49 176 42090978">+49 176 42090978</a></h5>
        <h5><a class="{% if now|is_night %}text-light{% else %}text-dark{% endif %}" href="mailto:hello@philippmatth.es">hello@philippmatth.es</a></h5>
        <h2 class="mt-5 bg-gradient-target bg-clip-text {{ gradient.css_class }}"
            style="font-size: 20px; font-weight: 700;">Created with ❤️ by Philipp Matthes.</h2>
        <p class="mt-2">Clara-Viebig-Straße 9, 01159 Dresden</p>
    </div>
</footer>

<script>
    document.addEventListener("DOMContentLoaded", function(event) {

        var camera, scene, renderer, mesh, geometry, meshRotations, meshRotationSpeeds;

        init();
        animate();

        function animate() {

            window.requestAnimationFrame(animate);
            for (var i = 0; i < meshRotations.length; i++) {
                meshRotations[i].x += meshRotationSpeeds[i];
                meshRotations[i].y += meshRotationSpeeds[i];
                meshRotations[i].z += meshRotationSpeeds[i];
            }
            renderer.render(scene, camera);

        }

        function onWindowResize() {
            var element = $("#visualization-demo");
            camera.aspect = element.innerWidth() / element.innerHeight();
            camera.updateProjectionMatrix();

            renderer.setSize(element.innerWidth(), element.innerHeight());
        }

        function onScroll(event) {
            var element = $("#visualization-demo");
            var top = element.offset().top;
            var bottom = element.offset().bottom;
            camera.position.z = ((window.scrollY - top) / 300.0);
        }

        function init() {
            var element = $("#visualization-demo");

            const zNear = 5.0;
            const zFar = 40.0;

            camera = new THREE.PerspectiveCamera(95, element.innerWidth() / element.innerHeight(), zNear, zFar);


            renderer = new THREE.WebGLRenderer({
                antialias: true, alpha: true
            });

            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(element.innerWidth(), element.innerHeight());
            element.prepend(renderer.domElement);

            scene = new THREE.Scene();

            var vertexShader = `
                uniform float zFar;
                uniform float zNear;

                varying vec2 vUv;
                varying vec3 vPosition;
                varying vec3 vIncident;
                varying vec3 vNormal;
                varying vec3 vDepth;
                varying vec3 vCameraPosition;

                vec3 calculateNormalizedDepth() {
                    float distanceToCamera = length(cameraPosition.xyz - position.xyz);
                    float normalizedDepth = (distanceToCamera) / (zNear + zFar);
                    return vec3(normalizedDepth);
                }

                void main()	{
                    vUv = uv;
                    vPosition = position;
                    vIncident = normalize(position.xyz - cameraPosition.xyz);
                    vNormal = normal;
                    vDepth = calculateNormalizedDepth();
                    vCameraPosition = cameraPosition.xyz;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            var fragmentShader = `
                #extension GL_OES_standard_derivatives : enable

                varying vec2 vUv;
                varying vec3 vPosition;
                varying vec3 vIncident;
                varying vec3 vNormal;
                varying vec3 vDepth;
                varying vec3 vCameraPosition;

                uniform float thickness;
                uniform vec3 colorStart;
                uniform vec3 colorEnd;

                float edgeFactor(vec2 p){
                    vec2 grid = abs(fract(p - 0.5) - 0.5) / fwidth(p) / thickness;
                    return min(1.0, max(0.0, min(grid.x, grid.y)));
                }

                void main() {
                    vec3 color = vec3(0.0);
                    color = mix(colorStart, colorEnd, length(vDepth));

                    float ambientStrength = 0.5;
                    vec3 vAmbient = ambientStrength * vec3(1.0);

                    vec3 vLightDir = normalize(vec3(25.0, 30.0, -10.0) - vPosition);
                    float diff = max(dot(vNormal, vLightDir), 0.0);
                    vec3 vDiffuse = diff * vec3(1.0);

                    float specularStrength = 1.0;
                    vec3 vViewDir = normalize(vCameraPosition - vPosition);
                    vec3 vReflectDir = reflect(-vLightDir, vNormal);
                    float spec = pow(max(dot(vViewDir, vReflectDir), 0.0), 32.0);
                    vec3 vSpecular = specularStrength * spec * vec3(1.0);

                    vec3 result = (vAmbient + vDiffuse + vSpecular) * color;

                    gl_FragColor = vec4(result, 1.0);
                }
            `;

            window.shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    thickness: {
                        value: 1.5
                    },
                    width: { value: window.innerWidth },
                    zNear: { value: zNear },
                    zFar: { value: zFar },
                    height: { value: window.innerHeight },
                    colorStart: {type: 'vec3', value: new THREE.Color("{{ gradient.color_start }}")},
                    colorEnd: {type: 'vec3', value: new THREE.Color("{{ gradient.color_end }}")},
                },
                vertexShader,
                fragmentShader
            });

            geometry = new THREE.TorusKnotBufferGeometry( 10, 0.5, 64, 8, 1, 10 );
            mesh = new THREE.Mesh( geometry, window.shaderMaterial );

            meshRotations = [];
            meshRotationSpeeds = [];

            var totalNumberOfRings = 5;
            for (var i = 0; i < totalNumberOfRings; i++) {
                var clonedMesh = mesh.clone();
                scene.add(clonedMesh);
                clonedMesh.position.set(0, 0, -25.0);
                if (i !== 0) {
                    var r = (i / totalNumberOfRings) * (Math.PI * 2.0);
                    clonedMesh.rotation.set(r, r, r);
                }
                meshRotations.push(clonedMesh.rotation);
                meshRotationSpeeds.push(Math.random() / 100);
            }

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener("scroll", onScroll);
        }

    });
</script>
